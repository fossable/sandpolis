//! # Agent Instance
//!
//! At a general level, agents are responsible for carrying out tasks for remote
//! users. They can connect over the network to any other type of instance. At
//! minimum, agents must be associated with one server.
//!
//! ## Instance Configuration
//!
//! ```py
//! # com.sandpolis.agent
//! {
//!   "network" : {
//!     "servers"          : [
//!       String(), # A server hostname and port
//!     ],
//!     "timeout"          : Number(default=1000),  # The server connection timeout in milliseconds
//!     "cooldown"         : Number(default=1000),  # How long to wait after each connection
//!     "strict_certs"     : Boolean(default=True), # The agent will refuse to connect to a server that presents an invalid certificate
//!     "polling_interval" : Number(default=0),     # The connection poll interval in seconds
//!   },
//!   "auth" : {
//!     "password"    : String(),
//!     "certificate" : String(),
//!   },
//!   "collectors": [
//!   	String()
//!   ]
//! }
//! ```
//!
//! ## Connection Modes
//!
//! There are two connection modes that have an impact on performance and latency.
//!
//! ### Continuous
//!
//! In continuous mode, the agent maintains its primary connection at all times. If
//! the connection is lost, the agent will periodically attempt to reestablish the
//! connection using the same parameters it used to establish the initial
//! connection.
//!
//! The connection mode can be changed on-the-fly by a user or scheduled to change
//! automatically according to the time and day.
//!
//! ### Polling
//!
//! In polling mode, the agent intentionally closes the primary connection unless
//! there exists an active stream. On a configurable schedule, the agent reconnects
//! to a server, flushes any cached data, and checks for any new work items. After
//! executing all available work items, the primary connection is closed again.
//!
//! The agent may attempt a spontaneous connection outside of the regular schedule
//! if an internal agent process triggers it.
//!
//! ## Standard Feature Set
//!
//! The standard feature set is the minimum amount of functionality an agent
//! implementation must provide.
//!
//! ### AgentMetadata
//!
//! ## Upgrades
//!
//! There are two ways to upgrade the agent:
//!
//! - automatically by sending the update command to the server,
//! - manually by generating a new installer and executing it on the agent
//!
//! ### Manual Upgrade
//!
//! A manual upgrade is triggered when an installer is executed on the agent and the
//! relevant base directory is already populated with an installation. If the agent
//! is not running, the installer will overwrite the base directory and install
//! itself. Any data that the agent has cached but not sent to the server will be
//! lost!
//!
//! Advantages
//!
//! - This is the only way to upgrade if the agent can no longer connect to the
//!   server
//!
//! Disadvantages
//!
//! - Manual intervention required
//! - Cached data may be lost
//!
//! ### Automated Upgrade
//!
//! If the agent is connected to a server, it can be upgraded remotely. This will
//! cause the server to fetch the agent configuration, generate a new installer, and
//! transfer it to the agent. The agent then executes the new installer and
//! terminates.
//!
//! ### Container Resident
//!
//! ## Boot Agent
//!
//! Several boot agent operations are accessible from typical agents.
//!
//! ### Installation
//!
//! Typical agent instances are capable of installing a boot agent on their host
//! machine if installed with sufficient permissions. Write access to the `EFI`
//! directory on the ESP partition is required for installation and uninstallation.
//!
//! The boot agent artifact is a standard `.efi` file generated by a server
//! instance. The agent simply copies the file to the ESP partition.
//!
//! ### Uninstallation
//!
//! To uninstall, an agent must simply delete the boot agent from the ESP partition.
//!
//! ### Reboot into boot agent
//!
//! Agents can launch the boot agent indirectly by setting the `BootNext` variable
//! to the index of the boot agent's EFI entry and rebooting the machine.
//!
//!
//! ## Installation Types
//!
//! There are three ways to install the agent, each with advantages and
//! disadvantages.
//!
//! ### Package Manager Installation
//!
//! This option makes installation itself easy, but requires some effort to
//! configure the agent to connect to a server. This installation type also means
//! that upgrades must only occur through the package manager.
//!
//! #### Filesystem Layout
//!
//! ##### Pacman (Arch Linux)
//!
//! | Path                                              | Description                |
//! | ------------------------------------------------- | -------------------------- |
//! | `/usr/lib/systemd/system/sandpolis-agent.service` | Systemd service definition |
//! | `/usr/bin/sandpolis-agent-config`                 | Configuration executable   |
//! | `/usr/bin/sandpolis-agent`                        | Main executable            |
//! | `/usr/share/java/sandpolis-agent/lib`             | `LIB` location             |
//! | `/usr/share/java/sandpolis-agent/plugin`          | `PLUGIN` location          |
//! | `/var/lib/sandpolis-agent/data`                   | `DATA` location            |
//!
//! ##### Apk (Alpine)
//!
//! ### Deployer Installation
//!
//! This option requires no explicit configuration, but the _deployer_ executable
//! must be transferred to the host and invoked explicitly.
//!
//! #### Filesystem Layout
//!
//! Deployers install everything under a single _base directory_ and create symbolic
//! links in certain locations outside of the base directory.
//!
//! | Platform | Default base directory path |
//! | -------- | --------------------------- |
//! | Linux    | `/opt/sandpolis-agent`      |
//! | Windows  |                             |
//! | macOS    |                             |
//!
//! ### Docker Installation
//!
//! This option is easy to deploy and configure, but can limit the functionality of
//! the agent in some cases.
//!
//! Certain elements of the host filesystem may be optionally mounted into the
//! container.
//!
//! ## Read-only Mode
//!
//! Agents can also run in "read-only" mode which will prohibit all write operations,
//! including to the configuration.
//!
//! This design is a security feature which ensures read-only agents cannot be compromised
//! even when the gateway server is compromised.

use anyhow::{bail, Result};
use axum::Router;
use clap::Parser;
use std::io::IsTerminal;
use std::path::PathBuf;
use tokio::net::UnixListener;
use tracing::info;

use crate::core::database::Database;
use crate::CommandLine;

pub mod layer;

#[derive(Parser, Debug, Clone, Default)]
pub struct AgentCommandLine {
    /// Prohibits all write operations
    #[clap(long, default_value_t = false)]
    pub read_only: bool,

    /// Instead of maintaining a persistent connection, poll the server on this cron expression
    pub poll: Option<String>,

    /// Agent socket
    #[clap(long)]
    //, value_parser = parse_storage_dir, default_value = default_storage_dir().into_os_string())]
    pub agent_socket: PathBuf,
    // TODO subcommands for operations on local control socket
}

#[derive(Clone)]
pub struct AgentState {
    pub db: Database,
}

pub async fn main(args: CommandLine) -> Result<()> {
    let mut db = Database::new(args.storage.join("agent.db"))?;

    info!("Starting agent instance");

    let _ = tokio::fs::remove_file(&args.agent_args.agent_socket).await;

    let uds = UnixListener::bind(&args.agent_args.agent_socket)?;
    tokio::spawn(async move {
        let app = Router::new();

        #[cfg(feature = "layer-shell")]
        let app = app.nest("/layer/shell", crate::agent::layer::shell::router());

        #[cfg(feature = "layer-package")]
        let app = app.nest("/layer/package", crate::agent::layer::package::router());

        #[cfg(feature = "layer-desktop")]
        let app = app.nest("/layer/desktop", crate::agent::layer::desktop::router());

        axum::serve(uds, app.into_make_service()).await.unwrap();
    });

    // TODO if a server is running in the same process, just use that
    if let Some(servers) = args.server {
        for server in servers {}
    } else {
        if std::io::stdout().is_terminal() {
            // TODO prompt
            print!("Please enter the server's address [127.0.0.1]: ");
        } else {
            bail!("Cannot configure server");
        }
    }

    // if prompt_bool("Configure client certificate authentication?", false) {}

    // if prompt_bool("Configure password authentication? ", false) {
    //     let password = prompt_string(
    //         "Enter password: ",
    //         "",
    //         &predicate::function(|x: &String| x.len() >= 5_usize),
    //     );
    // }

    return Ok(());
}
